import java.util.*;
import java.util.Comparator;
import java.util.Iterator;

public class SoftwareGurusBar
{
	private int freeChairs = 50; 
	private double profit = 0.0;
	
	SoftwareGurusBar () 
	{
		 int t = 0;
		 while (t < 240)
		 { 										
			 t += randBetween(2, 5); 				
			 simulation.scheduleEvent(new ArriveEvent(t, randBetween(1,5)));
		 } 		 										
		 simulation.run();
		 System.out.println("Total profits " + profit);
	} 
	
	private SimulationFramework simulation = new SimulationFramework(); 
	
	public static void main (String [ ] args)
	{
		 SoftwareGurusBar world = new SoftwareGurusBar ();
	}
	
	private int randBetween (int low, int high) 
	{
		 return low + (int) ((high - low + 1) * Math.random());
	} 
	
	// Class Method that check to see if there are available seats at the bar.  
	public boolean canSeat (int numberOfPeople)
		{
			 System.out.println("Group of " + numberOfPeople + " customers arrives at time " + simulation.time());
			 
			 // Checks to see if there are free seats. If true, seats the group and subtracts the open seats from 
			 // the free chairs. If there are no seats, returns false. 
			 if (numberOfPeople < freeChairs) 
			 {
				 System.out.println("Group is seated");
				 freeChairs -= numberOfPeople;
				 return true;
			 }else{
				 System.out.println("No Room, Group Leaves");
				 return false;
			 } 
		}

	// Class Method that outputs the order of each customer. 
	private void order (int beerType) 
		{
			 System.out.println("Serviced order for beer type " + beerType + " at time " + simulation.time());
			 
			 if (beerType == 1)
			 {
				 profit = profit + 2;
			 }
			 if (beerType == 2)
			 {
				 profit = profit + 3;
			 }
			 if (beerType == 3)
			 {
				 profit = profit + 4;
			 }
		} 
		
	// Class method that outputs when a group leaves the bar. Opens up free chairs. 
	private void leave (int numberOfPeople)
		{
			 System.out.println("Group of size " + numberOfPeople + " leaves at time " + simulation.time());
			 freeChairs += numberOfPeople;
		} 
		
	/*
	 * Class Event
	 * SuperClass to ArriveEvent, OrderEvent, LeaveEvent. 
	 * 
	 */
	public abstract class Event implements Comparable<Event>
	{
		public final int time;
		
		public Event (int t) 
		{
			time = t; 
		}
		
		abstract void processEvent ();

		public int compareTo (Event o) 
		{
			Event right = (Event) o;
			if (time < right.time) 
				{
					return -1;
				}
			if (time == right.time) 
				{
					return 0;
				}
			return 1;
		}
	}
	
	/* 
	 * Class ArriveEvent
	 * Extends Event
	 *
	 * Once the Arrive Event runs all of its code it runs the processEvent() method creating
	 * a new instance of Class Order Event and hands off the process to that class. 
	 */
	private class ArriveEvent extends Event 
	{
		// Variable that will store the number of people that arrive at the bar. 
		// This is a local variable and will only store the information for this group.
		 private int groupSize;
		 
		 // Class Constructor that will assign a number of people to the private variable. 
		 ArriveEvent (int time, int gs)
		 { 
			 super(time);
			 groupSize = gs;
		 }
		 
		 // Method that will process the data generated by the ArriveEevent class. 
		 public void processEvent () 
		 {
			 // Boolean check that will see if we have enough seats available at the bar.
			 // If seats are available at the bar the method will schedule a order event
			 // to take place at a random time. If seats are not available then the are 
			 // not seated. 
			 if (canSeat(groupSize)) 
			 {
				 simulation.scheduleEvent (new OrderEvent(time + randBetween(2,10), groupSize));
			 }
		 }
	} 
	
	/* 
	 * Class OrderEvent
	 */
	private class OrderEvent extends Event
	{
		// Variable that will store the number of people that arrive at the bar. 
		// This is a local variable and will only store the information for this group.
		 private int groupSize;
		 
		 
		 // Class Constructor that will assign a number of people to the private variable.
		 OrderEvent (int time, int gs)
		 { 
			 super(time);
			 groupSize = gs; 
		 }
		 
		 public void processEvent () 
		 {
			 // For loop that will cycle through each member of the group and generates a value from
			 // 1-3. This number will represent the beer the customer has ordered. It will be 
			 // passed into the order method to be added to the revenue of the bar. 
			
			 final Vector<Integer> weightedProbablityVector = new Vector<Integer>(3, 2); 
			 weightedProbablityVector.add(35); // Beer 1
			 weightedProbablityVector.add(45); // Beer 2
			 weightedProbablityVector.add(20); // Beer 3
			 
			
			 for (int i = 0; i < groupSize; i++)
			 { 
				 order(1 + simulation.WeightedProbablility(weightedProbablityVector));
			 }
			 
			 simulation.scheduleEvent (new LeaveEvent(time + randBetween(20,60), groupSize));
		 }
	 }
	
	/*
	 * Class LeaveEvent
	 * Extends Event
	 */
	private class LeaveEvent extends Event
	{
		// Variable that will store the number of people that arrive at the bar. 
		// This is a local variable and will only store the information for this group.
		private int groupSize;
		
		// Class Constructor that will assign a number of people to the private variable. 
		 LeaveEvent (int time, int gs) 
		 {
			 super(time);
			 groupSize = gs; 
		 }
		 
		 // Method that calls the leave method from the Event class and passes in the 
		 // group size of the current group. 
		 public void processEvent () 
		 { 
			 leave(groupSize); 
		 }
	} 

	public class SimulationFramework 
	{
		private int currentTime = 0;
		private PriorityQueue<Event> eventQueue = new PriorityQueue<Event>(50, new DefaultComparator());
		
		
		
		//// Schedules an Event in the Priority Queue. 
		public void scheduleEvent (Event newEvent) 
		{ 
				eventQueue.add(newEvent); 
		}
		
		// Runs the simulation. 
		public void run () 
		{
	
			
			while (!eventQueue.isEmpty()) 
			{
				Event nextEvent = (Event) eventQueue.peek();
				eventQueue.remove();
				currentTime = nextEvent.time;
				nextEvent.processEvent();
			}
		}
		
		// Returns the current Simulation time. 
		public int time () 
		{ 
			return currentTime;
		}
		
		public int WeightedProbablility (Vector<Integer> obj)
		{
			Integer sumOfVector = 0;
			Iterator<Integer> itr = obj.iterator();
			
			
			while(itr.hasNext())
		    {
		        sumOfVector = sumOfVector + itr.next();
		    }
			
			Integer random = randBetween(1 ,sumOfVector);
			
			if (random < 35)
			{
				return 0;
			}
			if (random < 80)
			{
				return 1;
			}
			else
			{
				return 2;
			}
		}
	}
	
	
	public class DefaultComparator implements Comparator<Event>
	{
		public DefaultComparator()
			{
		
			}
			
		public int compare(Event left, Event right)
		{
			 
			if(left.time < right.time)
			{
				return -1;
			}
			//If right less then left returns 1. 
			if(right.time < left.time)
			{
				return 1;
			}
			// If equal returns 0. 
			return 0;
		}
		
		public boolean equals(Event obj)
		{
			
			 return true;  
		} 	
	}
}